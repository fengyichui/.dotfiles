#!/usr/bin/env bash

# apt-cyg: install tool for cygwin similar to debian apt-get

# The MIT License (MIT)
# 
# Copyright (c) 2013 Trans-code Design
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# 

TRUSTEDKEYS=( CYGWIN CYGWINPORTS );
# ./pubring.asc
# ------------
# pub   1024D/676041BA 2008-06-13
# uid                  Cygwin <cygwin@cygwin.com>
# sub   1024g/A1DB7B5C 2008-06-13
TRUSTEDKEY_CYGWIN_SUM="e6630b94e6bf1afcc1b1054afa9994a423764d795b2a3a5e831fc658962905dcadf63c3a29155136f3138d6375176c9384de68d12a6dd4dde35b55c9b225cd7f"
TRUSTEDKEY_CYGWIN_FPR="1169DF9F22734F743AA59232A9A262FF676041BA"
TRUSTEDKEY_CYGWIN_URL_LATEST="https://cygwin.com/key/pubring.asc"
# ./ports.gpg
# -----------
# pub   1024D/66EE1F94 2008-10-27
# uid                  Yaakov Selkowitz (Cygwin Ports) <yselkowitz@users.sourceforge.net>
# sub   4096g/7D66B0D2 2008-10-27
TRUSTEDKEY_CYGWINPORTS_SUM="ccf174d1e6ec20e50ff954e3d4a0c3de478032a100d26789c0190587ae80128e842ff5404ed3b48f8693c8803c88a3acbf8dca339edfdaab0f3c247fb6091e42"
TRUSTEDKEY_CYGWINPORTS_FPR="45600BB98CA878AA97A70119FF20AF9A66EE1F94"
TRUSTEDKEY_CYGWINPORTS_URL_LATEST="http://cygwinports.org/ports.gpg"

(( 5 <= "${DEBUG:-0}" )) && set -x

# this script requires some packages

WGET="$( which wget 2>/dev/null )"
TAR="$(  which tar  2>/dev/null )"
GAWK="$( which awk  2>/dev/null )"
GPGV="$( which gpgv 2>/dev/null )"
GPG="$(  which gpg  2>/dev/null )"
if [ -z "$WGET" -o -z "$TAR" -o -z "$GAWK" ]; then
  echo You must install wget, tar and gawk to use apt-cyg.
  exit 1
fi

function usage()
{
  echo apt-cyg: Installs and removes Cygwin packages.
  echo "  \"apt-cyg install <package names>\" to install packages"
  echo "  \"apt-cyg remove <package names>\" to remove packages"
  echo "  \"apt-cyg update\" to update setup.ini"
  echo "  \"apt-cyg show\" to show installed packages"
  echo "  \"apt-cyg find <patterns>\" to find packages matching patterns"
  echo "  \"apt-cyg describe <patterns>\" to describe packages matching patterns"
  echo "  \"apt-cyg packageof <commands or files>\" to locate parent packages"
  echo "  \"apt-cyg pathof <cache|mirror|mirrordir|cache/mirrordir|setup.ini>\""
  echo "                                                          to show path"
  echo "  \"apt-cyg key-add <files> ...\" to add keys contained in <files>"
  echo "  \"apt-cyg key-del <keyids> ...\" to remove keys <keyids>"
  echo "  \"apt-cyg key-list\" to list keys"
  echo "  \"apt-cyg key-finger\" to list fingerprints"
  echo "  \"apt-cyg upgrade-self\" to upgrade apt-cyg"
  echo "  \"apt-cyg depends <package names>\""
  echo "         to show forward dependency information for packages with depth."
  echo "  \"apt-cyg rdepends <package names>\""
  echo "         to show reverse dependency information for packages with depth."
  echo "  \"apt-cyg completion-install\" to install completion."
  echo "  \"apt-cyg completion-uninstall\" to uninstall completion."
  echo "  \"apt-cyg mirrors-list\" to show list of mirros."
  echo "  \"apt-cyg benchmark-mirrors <url> ...\" to benchmark mirrors."
  echo "  \"apt-cyg benchmark-parallel-mirrors <url> ...\" to benchmark mirrors in parallel."
  echo "  \"apt-cyg benchmark-parallel-mirrors-list\" to benchmark mirrors-list in parallel."
  echo "  \"apt-cyg scriptinfo\" to show script infomations."
  echo "  \"apt-cyg show-packages-busyness <package names> ...\" to show packages are busy or noe."
  echo "  \"apt-cyg dist-upgrade\" to upgrade all packages that is installed. This subcommand uses setup.exe"
  echo "  \"apt-cyg update-setup\" to update setup.exe"
  echo "  \"apt-cyg setup\" to call setup.exe"
  echo "  \"apt-cyg packages-total-count\" count number of total packages from setup.ini"
  echo "  \"apt-cyg packages-total-size [pattern_of_section]\" count size of total packages from setup.ini"
  echo "  \"apt-cyg packages-cached-count\" count number of cached packages in cache/mirrordir."
  echo "  \"apt-cyg packages-cached-size\" count size of cached packages in cache/mirrordir."
  echo "  \"apt-cyg repair-acl\" repair acl."
  echo "  \"apt-cyg source\" download source archive."
  echo "  \"apt-cyg download\" download the binary package into the current directory."
  echo "  \"apt-cyg mirror\" download the binary package into the current cache/mirrordir as mirror."
  echo "Options:"
  echo "  --ag                     : use the silver searcher (currently work only at packageof subcommand)"
  echo "  --charch <arch>          : change archetecture"
  echo "  --use-setuprc            : set cache and mirror with /etc/setup/setup.rc"
  echo "  --use-own-conf           : use own cache and mirror settings when apt-cyg calls setup.exe"
  echo "  --ignore-case, -i        : ignore case distinctions for <patterns>"
  echo "  --force-remove           : force remove"
  echo "  --force-fetch-trustedkeys: force fetch trustedkeys"
  echo "  --force-update-packageof-cache:"
  echo "                             force update packageof cache"
  echo "  --no-verify, -X          : Don't verify setup.ini signatures"
  echo "  --no-check-certificate   : Don't validate the server's certificate"
  echo "  --no-update-setup        : Don't update setup.exe"
  echo "  --no-header              : Don't print header"
  echo "  --proxy, -p <auto|inherit|none|URL> :"
  echo "                             set proxy (default: \${APT_CYG_PROXY:-auto})"
  echo "  --completion-get-subcommand:"
  echo "                             get subcommand (for completion internal use)"
  echo "  --completion-disable-autoupdate:"
  echo "                             disable completion autoupdate"
  echo "  --max-jobs, -j <n>       : Run n jobs in parallel"
  echo "  --mirror, -m <url>       : set mirror"
  echo "  --cache, -c <dir>        : set cache"
  echo "  --file, -f <file>        : read package names from file"
  echo "  --noupdate, -u           : don't update setup.ini from mirror"
  echo "  --ipv4, -4               : wget prefer ipv4"
  echo "  --no-progress            : hide the progress bar in any verbosity mode"
  echo "  --quiet, -q              : quiet (no output)"
  echo "  --verbose, -v            : verbose"
  echo "  --help"
  echo "  --version"
}



function version()
{
  echo "apt-cyg version 0.57"
  echo "Written by Stephen Jungels"
  echo ""
  echo "Copyright (c) 2005-9 Stephen Jungels.  Released under the GPL."
}

# Usage: verbose [level [msg ...]]
function verbose ()
{
  (( "${OPT_VERBOSE_LEVEL}" < "${1:-1}" )) && return
  shift
  (( 0 < $# )) && echo "$@" || cat
} >&2

# Usage: verbosefor [level]
function verbosefor ()
{
  (( ${OPT_VERBOSE_LEVEL} < ${1:-1} )) && echo "/dev/null" || echo "/dev/stderr"
}

function current_cygarch ()
{
  arch | sed -e 's/^i686$/x86/g'
}

function mirror_to_mirrordir ()
{
  echo "$1" | sed -e "s/:/%3a/g" -e "s:/:%2f:g"
}

function findworkspace()
{
  # default working directory, mirror and architecture

  mirror=http://ftp.jaist.ac.jp/pub/cygwin
  arch="$(current_cygarch)"
  cache=/setup
  
  # work wherever setup worked last, if possible
  
  if [ -e /etc/setup/last-cache ]; then
    cache="$(cygpath -au "$(head -1 /etc/setup/last-cache)")"
  fi
  cache="${cache%/}"
  
  if [ -e /etc/setup/last-mirror ]; then
    mirror="$(head -1 /etc/setup/last-mirror)"
  fi
  mirror="${mirror%/}"
  mirrordir="$(mirror_to_mirrordir "$mirror/")"
  
  verbose 1 "Cache directory is $cache"
  verbose 1 "Mirror is $mirror"
  mkdir -p "$cache/$mirrordir/$arch"
  cd "$cache/$mirrordir/$arch"
  
  init_gnupg
  fetch_trustedkeys
}

function download_and_verify ()
{
  "${WGET[@]}" -N "$1" || return 1
  [ -e "${1##*/}" ] || return 1
  if [ -z "$no_verify" ]; then
    "${WGET[@]}" -N "${1}.sig" || return 1
    [ -e "${1##*/}.sig" ] && verify_signatures "${1##*/}.sig" || { rm -f "${1##*/}" "${1##*/}.sig"; return 1; }
  fi
  return
}

function files_backup ()
{
  local file
  for file; do
    [ -e "${file}~" ] && mv    "${file}~" "${file}"
    [ -e "${file}"  ] && cp -a "${file}"  "${file}~"
  done
}

function files_restore ()
{
  local file
  for file; do
    [ -e "${file}"  ] && rm    "${file}"
    [ -e "${file}~" ] && mv    "${file}~" "${file}"
  done
}

function files_backup_clean ()
{
  local file
  for file; do
    [ -e "${file}~" ] && rm    "${file}~"
  done
}

function setupini_download ()
{
  local BASEDIR="$cache/$mirrordir/$arch"
  mkdir -p "$BASEDIR" || { echo -e "\e[31;1mError:\e[30;0m mkdir \"$BASEDIR\" failed."; exit 1; }
  
  [ $noscripts -ne 0 -o $noupdate -ne 0 ] && return
  
  pushd "$BASEDIR" > /dev/null
  files_backup setup.ini setup.ini.sig setup.bz2 setup.bz2.sig
  
  while true; do
    verbose 1 "Updating setup.ini"
    download_and_verify "$mirror/$arch/setup.bz2" && { bunzip2 -k setup.bz2 && mv setup setup.ini || rm -f setup.bz2; }
    download_and_verify "$mirror/$arch/setup.ini" || break
    
    files_backup_clean setup.ini setup.ini.sig setup.bz2 setup.bz2.sig
    popd > /dev/null
    verbose 1 "Updated setup.ini"
    return
  done
  files_restore setup.ini setup.ini.sig setup.bz2 setup.bz2.sig
  popd > /dev/null
  echo -e "\e[31;1mError:\e[30;0m updating setup.ini, reverting." >&2
  return 1
}

function getsetup ()
{
  setupini_download || return 1
}

function checkpackages()
{
  if [ $# -eq 0 ]; then
    echo Nothing to do, exiting
    exit 0
  fi
}

# Usage: getrootdir arch
function getrootdir ()
{
  case "$1" in
    x86)
      cygpath -u "$(< /proc/registry32/HKEY_LOCAL_MACHINE/SOFTWARE/Cygwin/setup/rootdir)" ;;
    x86_64)
      cygpath -u "$(< /proc/registry64/HKEY_LOCAL_MACHINE/SOFTWARE/Cygwin/setup/rootdir)" ;;
    *)
      echo -e "\e[31;1mError:\e[30;0m unknown arch $1" >&2 ;;
  esac
}

# Usage: charch arch apt-cyg_parms ...
function charch ()
{
  local rootdir
  if [ "$(current_cygarch)" != "$1" ]; then
    echo -e "\e[32;1mcharch to:\e[30;0m $1"
    rootdir="$(getrootdir "$1")"
    shift
    chroot "$rootdir" "$rootdir/bin/bash" -lc \
      'cd "$1"; shift ; "$0" "$@"' \
      "$(which "$0" | xargs cygpath -aml | xargs cygpath -u)" \
      "$(pwd        | xargs cygpath -aml | xargs cygpath -u)" \
      "$@"
    exit $?
  fi
}

function init_gnupg ()
{
  [ -z "$GPG" ] && return
  export GNUPGHOME="$cache/.apt-cyg"
  if [ ! -d "$GNUPGHOME" ]; then
    if ! { mkdir -p "$GNUPGHOME" && chmod 700 "$GNUPGHOME"; } then
      echo -e "\e[31;1mError:\e[30;0m cannot initialize directory $GNUPGHOME"
      exit 1
    fi
  fi
  GPG_KEYRING=( --keyring pubring.gpg )
}

# Usage: ask_user [MESSAGE [OPTIONS]]
function ask_user ()
{
  local answer retcode option
  local MESSAGE="$1"
  local OPTIONS="${2:-y/N}"
  local DEFAULT="$(echo "$OPTIONS" | awk -v FS=/ '{for(i=1;i<=NF;i++)if(match(substr($i,1,1),/[A-Z]/)){print $i; exit}}')"
  local SPLIT_OPTIONS
  readarray -t SPLIT_OPTIONS < <(echo "$OPTIONS" | sed -e 's:/:\n:g')
  while true; do
    echo -n "${MESSAGE}${MESSAGE:+ }[${OPTIONS}] "
    read answer
    retcode=0
    for option in "${SPLIT_OPTIONS[@]}"; do
      if [ "$option" = "${answer:-$DEFAULT}" ]; then
        return $retcode
      fi
      retcode=$(( retcode + 1 ))
    done
  done
}

# Reference:
# https://www.gnu.org/software/wget/manual/wget.html#Exit-Status
# Usage: wget-exitstatus EXITSTATUS
function wget-exitstatus ()
{
  case $1 in
  0) echo "No problems occurred.";;
  1) echo "Generic error code.";;
  2) echo "Parse error?for instance, when parsing command-line options, the '.wgetrc' or '.netrc'...";;
  3) echo "File I/O error.";;
  4) echo "Network failure.";;
  5) echo "SSL verification failure.";;
  6) echo "Username/password authentication failure.";;
  7) echo "Protocol errors.";;
  8) echo "Server issued an error response.";;
  *) echo "Unknown errors.";;
  esac
}

function wget_advice ()
{
  local status=${1:-$?}
  case $status in
  5) echo "If you can tolerate security risks, use --no-certification option." ;;
  esac
  return $status
}

# Usage: get_advice cmd
function get_advice ()
{
  local status=${2:-$?}
  type "${1}_advice" >&/dev/nul && { ( exit $status ); "${1}_advice"; }
  return $status
}

# Usage: push_advice cmd
function push_advice ()
{
  local status=${2:-$?}
  ADVICE+=( "$( get_advice "${1}_advice")" )
  return $status
}

function show_advice ()
{
  local i
  for i in "${ADVICE[@]}"; do
    echo "$i" >&2
  done
}

# Usage: wget_and_hash_check label hash url file
function wget_and_hash_check ()
{
  local LABEL="$1"
  local SUM="$2"
  local URL="$3"
  local FILE="$4"
  if ! { "${WGET[@]}" "$URL" -O "$FILE" || get_advice wget; }; then
    echo "$LABEL: FAILED: Could not download $URL."
    return 1
  fi
  if ! hash_check <<<"$SUM *$FILE" >&/dev/null; then
    echo "$LABEL: FAILED: Hash does not match $URL."
    return 2
  fi
  echo "$LABEL: OK"
}

function fetch_trustedkeys ()
{
  [ -z "$GPG" ] && return
  local i
  local FILE="$(mktemp)"
  local FILE_LATEST="$(mktemp)"
  for i in "${TRUSTEDKEYS[@]}"; do
    local LABEL="TRUSTEDKEY_${i}"
    local SUM="$(eval echo "\$${LABEL}_SUM")"
    local FPR="$(eval echo "\$${LABEL}_FPR")"
    local URL="$(eval echo "\$${LABEL}_URL")"
    local URL_LATEST="$(eval echo "\$${LABEL}_URL_LATEST")"
    local CASE=""
    if [ -z "$force_fetch_trustedkeys" ] && { "${GPG[@]}" --fingerprint --with-colons | grep -q "$FPR"; } &> $(verbosefor 2); then
      continue
    fi
    if [ -n "$URL" ]; then
      wget_and_hash_check "$LABEL" "$SUM" "$URL" "$FILE"
      CASE+="$?"
    else
      CASE+="-"
    fi
    if [ -n "$URL_LATEST" ]; then
      wget_and_hash_check "$LABEL" "$SUM" "$URL_LATEST" "$FILE_LATEST"
      CASE+="$?"
    else
      CASE+="-"
    fi
    case "$CASE" in
      00|01|0-)
        "${GPG[@]}" --import "$FILE"
        ;;
      02)
        echo "Warning: ${LABEL} has been updated."
        "${GPG[@]}" --import "$FILE"
        ;;
      -0)
        "${GPG[@]}" --import "$FILE_LATEST"
        ;;
      10|20)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has miss configuration."
        exit 1
        ;;
      11|1-|-1)
        echo -e "\e[31;1mError:\e[30;0m Could not download ${LABEL}."
        exit 1
        ;;
      12|-2)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has been updated, maybe. But sometimes it may has been cracked. Be careful !!!"
        exit 1
        ;;
      21|22|2-)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has been cracked, maybe"
        exit 1
        ;;
      --)
        echo -e "\e[31;1mError:\e[30;0m ${LABEL} has no URL."
        exit 1
        ;;
    esac
  done
  rm "$FILE" "$FILE_LATEST"
}

# Usage: verify_signatures files ...
function verify_signatures ()
{
  while [ $# -gt 0 ]; do
    if ! "${GPG[@]}" "${GPG_KEYRING[@]}" "$1" &> $(verbosefor 2); then
      echo -e "\e[31;1mError:\e[30;0m BAD signature: $1" >&2
      return 1
    else
      verbose 0 -e "\e[32;1msignature verified\e[30;0m: $1"
    fi
    shift
  done
}

# Usage: apt-cyg-key-add pkey ...
function apt-cyg-key-add ()
{
  [ -z "$GPG" ] && { echo -e "\e[31;1mError:\e[30;0m GnuPG is not installed. Prease install gnupg package"; exit 1; }
  local pkeys
  for pkey; do
    pkeys+=( "$(cygpath -a "$pkey" )" )
  done
  findworkspace
  for pkey in "${pkeys[@]}"; do
    "${GPG[@]}" --import "$pkey"
  done
}

# Usage: apt-cyg-key-add keyid ...
function apt-cyg-key-del ()
{
  [ -z "$GPG" ] && { echo -e "\e[31;1mError:\e[30;0m GnuPG is not installed. Prease install gnupg package"; exit 1; }
  local keyid
  findworkspace
  for keyid; do
    "${GPG[@]}" --batch --yes --delete-key "$keyid"
  done
}

function apt-cyg-key-list ()
{
  [ -z "$GPG" ] && { echo -e "\e[31;1mError:\e[30;0m GnuPG is not installed. Prease install gnupg package"; exit 1; }
  findworkspace
  "${GPG[@]}" --list-keys
}

function apt-cyg-key-finger ()
{
  [ -z "$GPG" ] && { echo -e "\e[31;1mError:\e[30;0m GnuPG is not installed. Prease install gnupg package"; exit 1; }
  findworkspace
  "${GPG[@]}" --fingerprint
}

function apt-cyg-pathof ()
{
  findworkspace >& /dev/null
  while [ "$#" -gt 0 ]; do
    case "$1" in
      cache)            echo "$cache" ;;
      mirror)           echo "$mirror" ;;
      mirrordir)        echo "$mirrordir" ;;
      cache/mirrordir)  echo "$cache/$mirrordir" ;;
      setup.ini)        echo "$cache/$mirrordir/$arch/setup.ini" ;;
      *)
        echo -e "\e[31;1mError:\e[30;0m in function $FUNCNAME: unknown parameter: $1"
        exit 1
        ;;
    esac
    shift
  done
}

function apt-cyg-upgrade-self ()
{
  local basedir="$(dirname "$(readlink -f "$(which "$0")")")"
  if [ ! -d "$basedir/.git" ]; then
    echo -e "\e[31;1mError:\e[30;0m apt-cyg is not under the git version control."
    exit 1
  fi
  pushd "$basedir" > /dev/null
  git pull -v
  popd > /dev/null
}

function proxy_auto ()
{
  local hash="$(ipconfig 2>&1 | md5sum -b | awk '{print $1}')"
  local cache="/tmp/apt-cyg.proxy.$hash"
  local last="$(stat -c %Y "$cache" 2>/dev/null)"
  local now="$(date +%s)"
  local proxy
  
  [ -n "$OPT_PROXY_FORCE_REFRESH" ] && last=0
  if (( (now - ${last:-0}) < OPT_PROXY_REFRESH_INTERVAL )); then
    proxy="$(<"$cache")"
  else
    proxy=$("${WGET[@]}" --no-proxy -q -O - wpad/wpad.dat \
    | grep PROXY \
    | sed -e 's/^.*PROXY\s*\([^"]*\).*$/http:\/\/\1/g')
    echo "$proxy" > "$cache"
  fi
  [ -n "$proxy" ] && proxy_set "$proxy"
}

function proxy_set ()
{
  export http_proxy="$1"
  export https_proxy="$1"
  export ftp_proxy="$1"
}

function proxy_unset ()
{
  export -n http_proxy
  export -n https_proxy
  export -n ftp_proxy
}

function proxy_setup ()
{
  case "$OPT_PROXY" in
    auto)
      proxy_auto
      ;;
    inherit)
      ;;
    none)
      proxy_unset
      ;;
    *)
      proxy_set "$OPT_PROXY"
      ;;
  esac
}

# Usage: get_pkgname PKGFILE
function get_pkgname ()
{
  local tarball="${1##*/}"
  echo "$tarball" | sed -re's/-[0-9].*//g'
}

# PACKAGE_DB is defined at package_db.cc in the cygwin-app setup.exe
# See blow:
# https://www.sourceware.org/cygwin-apps/setup.html
# https://sourceware.org/cgi-bin/cvsweb.cgi/setup/package_db.cc?cvsroot=cygwin-apps
PACKAGE_DB="/etc/setup/installed.db"

function package_db-version_check ()
{
  [ -n "$PACKAGE_DB_VERSION_CHECK_DONE" ] && return
  
  local vernhdr='INSTALLED\.DB [0-9]+'
  local line1="$(head -n1 "${PACKAGE_DB}")"
  local verhdr=( $line1 )
  local pkgname="${verhdr[0]}"
  local dbver
  [ "${verhdr[0]}" = "INSTALLED.DB" ] && dbver="${verhdr[1]}" || dbver="1"
  
  if echo "$line1" | grep -Eqvx "${vernhdr}"; then
    echo -e "\e[33;1mWarning:\e[30;0m ${PACKAGE_DB} does not have version header. The first line is below:" >&2
    echo -e "$(head -n1 "${PACKAGE_DB}")\n" >&2
    
    # The earlyer version of apt-cyg was not treat version header correctly.
    if grep -EHnx "${vernhdr}" "${PACKAGE_DB}" >&2; then
      echo -e "The above line looks like version header, but it is not the first line.\n" >&2
    fi
  fi
  
  if (( dbver < 3 )); then
    echo -e "\e[33;1mWarning:\e[30;0m ${PACKAGE_DB} version is less than 3." >&2
    echo -e "Before continuing, recommend to execute below command:" >&2
    echo -e "    apt-cyg dist-upgrade" >&2
    ask_user "Do you continue?" >&2 && {
      echo "continue" >&2
    } || {
      echo "abort" >&2
      exit 1
    }
  fi
  
  if (( 3 < dbver )); then
    echo -e "\e[31;1mError:\e[30;0m ${PACKAGE_DB} has unknown version header." >&2
    echo -e "Currently apt-cyg supports the DB of ver 3 or ealyer, but your DB is ver $dbver." >&2
    ask_user "Do you want to continue at your own risk?" >&2 && {
      echo "continue" >&2
    } || {
      echo "abort" >&2
      exit 1
    }
  fi
  
  PACKAGE_DB_VERSION_CHECK_DONE=1
}

# Usage: package_db-is_registered PKGNAME
function package_db-is_registered ()
{
  package_db-version_check
  
  awk '
    $1 == PKGNAME && NF != 2 {found = 1; exit}
    END {exit !found}
  ' PKGNAME="$1" "${PACKAGE_DB}"
}

function package_db-list ()
{
  package_db-version_check
  
  awk '
    NF == 3 {
      version = gensub(/^(.*)\.(tgz|tbz|tbz2|tb2|taz|tz|tlz|txz|tar\.(gz|bz2|Z|lz|lzma|xz))$/, "\\1", 1, substr($2, length($1) + 2));
      printf("%-45s %s\n", $1, version);
    }
  ' "${PACKAGE_DB}"
}

# Usage: package_db-register PKGFILE USER_PICKED=0
function package_db-register ()
{
  local pkgfile="${1##*/}"
  local pkgname="$(get_pkgname "$pkgfile")"
  local user_picked="${2:-0}"
  local work="/tmp/apt-cyg.$$.${PACKAGE_DB##*/}"
  
  package_db-version_check
  
  awk '
    function register() {print PKGNAME " " PKGFILE " " USER_PICKED; registered = 1;}
    !registered && PKGNAME < $1 && NF != 2 {register()}
    {print $0}
    END {if (!registered) register()}
  ' PKGNAME="$pkgname" PKGFILE="${pkgfile}" USER_PICKED="${user_picked}" "${PACKAGE_DB}" > "${work}"
  
  mv "${PACKAGE_DB}" "${PACKAGE_DB}-save"
  mv "${work}"       "${PACKAGE_DB}"
}

# Usage: package_db-unregister PKGNAME
function package_db-unregister ()
{
  local work="/tmp/apt-cyg.$$.${PACKAGE_DB##*/}"
  
  package_db-version_check
  
  awk '!(PKGNAME == $1 && NF != 2) {print $0}' PKGNAME="$1" "${PACKAGE_DB}" > "${work}"
  
  mv "${PACKAGE_DB}" "${PACKAGE_DB}-save"
  mv "${work}"       "${PACKAGE_DB}"
}

# Usage: join FS fields ...
function join ()
{
  local FS="$1" field="" result="" sep=""
  shift
  for field; do
    result="$result$sep$field"
    sep="$FS"
  done
  echo -n "$result"
}

# Usage: dep_check DIR ROOTPKGS ...
# Parameters:
#   DIR is "depends" or "rdepends".
#   ROOTPKGS is root package names to check dependency.
# Return:
#   package_name available shallow_depth deep_depth
function dep_check ()
{
  awk \
  '
    function min(x,y) {return x < y ? x : y}
    function max(x,y) {return x < y ? y : x}
    function update_result(dir, rootpkg, pkg, depth, _, i) {
      if (0 + result[rootpkg, pkg, "deep"]) {
        result[rootpkg, pkg, "shallow"] = min(depth, result[rootpkg, pkg, "shallow"]);
        result[rootpkg, pkg, "deep"]    = max(depth, result[rootpkg, pkg, "deep"]);
      } else {
        result[rootpkg, pkg, "deep"] = result[rootpkg, pkg, "shallow"] = depth;
        result[rootpkg, pkg, "available"] = 0 + available[pkg];
        result[rootpkg, result[rootpkg, "n"]++] = pkg;
        for (i = 0; i < dep[dir, pkg, "n"]; i++) {
          update_result(dir, rootpkg, dep[dir, pkg, i], depth + 1);
        }
      }
    }
    $1 == "@" {
      pkg = $2;
      available[pkg] = 1;
    }
    $1 == "requires:" {
      for (req = 2; req <= NF; req++) {
        dep["rdepends", $req, dep["rdepends", $req, "n"]++] = pkg;
        dep["depends" , pkg , dep["depends" , pkg , "n"]++] = $req;
      }
    }
    END {
      split(ROOTPKGS, rootpkgs, "\x1c");
      for (k in rootpkgs) {
        update_result(DIR, rootpkgs[k], rootpkgs[k], 1);
        for(i = 0; i < result[rootpkgs[k], "n"]; i++) {
          printf("%-40s %d\t%d\t%d\n",
            result[rootpkgs[k], i],
            result[rootpkgs[k], result[rootpkgs[k], i], "available"],
            result[rootpkgs[k], result[rootpkgs[k], i], "shallow"],
            result[rootpkgs[k], result[rootpkgs[k], i], "deep"]);
        }
      }
    }
  ' \
  DIR="$1" ROOTPKGS="$(join $'\x1c' "${@:2}")" "$(apt-cyg-pathof "setup.ini")" \
  | awk '
    function min(x,y) {return x < y ? x : y}
    function max(x,y) {return x < y ? y : x}
    {
      packages[$1] = pkg = $1;
      status[pkg, "available"] = $2;
      status[pkg, "shallow"  ] = 0 + status[pkg, "shallow"] == 0 ? $3 : min(status[pkg, "shallow"], $3);
      status[pkg, "deep"     ] = max(0 + status[pkg, "deep"], $4);
    }
    END {
      for (pkg in packages) {
        printf("%-40s %d\t%d\t%d\n",
          pkg,
          status[pkg, "available"],
          status[pkg, "shallow"],
          status[pkg, "deep"])
      }
    }
  ' | sort -nrk4
}

function apt-cyg-depends ()
{
  local pkg
  [ -z "$OPT_NO_HEADER" ] && printf "%-40s %s\t%s\t%s\n" "PKGNAME" "AVAIL" "SHALLOW" "DEEP"
  dep_check depends "$@"
}

function apt-cyg-rdepends ()
{
  local pkg
  [ -z "$OPT_NO_HEADER" ] && printf "%-40s %s\t%s\t%s\n" "PKGNAME" "AVAIL" "SHALLOW" "DEEP"
  dep_check rdepends "$@"
}

function apt-cyg-completion-install ()
{
  if [ ! -d "/etc/bash_completion.d" ]; then
    echo -e "\e[31;1mError:\e[30;0m /etc/bash_completion.d is not exist."
    exit 1
  fi
  if ! package_db-is_registered "bash-completion"; then
    echo -e "\e[31;1mError:\e[30;0m bash-completion is not installed."
    exit 1
  fi
  
  local SUBCMDS
  local OPTIONS
  local SCRIPTFILE="$(realpath "$(which apt-cyg)")"
  local SCRIPTDIR="${SCRIPTNAME%/*}"
  
  readarray -t -O ${#SUBCMDS[@]} SUBCMDS < <(grep "^function " "$SCRIPTFILE" | awk 'match($2, /apt-cyg-([-_0-9A-Za-z]+)/,m){print m[1]}')
  readarray -t -O ${#OPTIONS[@]} OPTIONS < <(
    awk '
      /^function *parse_args *\(\)/ {proc=1}
      /^} *# *\/parse_args( |$)/    {proc=0}
      proc && match($0, /^ *(-[^()*]+)\)/, m) {
        split(m[1], x, "|");
        for (i in x) print x[i];
      }
      ' "$SCRIPTFILE"
    )
  cat <<-EOD > /etc/bash_completion.d/apt-cyg
# bash completion for apt-cyg

function __apt-cyg ()
{
  local cur prev getsubcmd subcmd
  
  # Auto update for completion script.
  if [ -z "$OPT_COMPLETION_DISABLE_AUTOUPDATE" -a "$SCRIPTFILE" -nt "/etc/bash_completion.d/apt-cyg" ]; then
    apt-cyg completion-install >/dev/null 2>&1
    . /etc/bash_completion.d/apt-cyg
    __apt-cyg "$@"
    return
  fi
  
  _get_comp_words_by_ref -n : cur prev
  
  getsubcmd=( apt-cyg --completion-get-subcommand \$(echo "\${COMP_LINE}" | sed -r -e 's/^[^ \t]+//g' -e 's/[^ \t]+\$//g') )
  subcmd="\$( "\${getsubcmd[@]}" )"
  
  case "\$subcmd" in
    install|depends|rdepends|describe|find)
      COMPREPLY=( \$(awk '/^@ /{print \$2}' "$(apt-cyg pathof setup.ini)") )
      ;;
    remove)
      COMPREPLY=( \$(apt-cyg show 2>/dev/null) )
      ;;
    pathof)
      COMPREPLY=( cache mirror mirrordir cache/mirrordir setup.ini )
      ;;
    "")
      COMPREPLY=( "${SUBCMDS[*]}" )
      ;;
  esac
  case "\$prev" in
    --charch)
      COMPREPLY=( x86 x86_64 )
      ;;
    --cache|-c)
      COMPREPLY=( \$(compgen -d -- "\$cur") )
      ;;
    --mirror|-m)
      COMPREPLY=( \$(awk '/^[^ \t]+/{section=\$1}section=="mirrors-lst"&&match(\$0,/^[ \t]+([^;]+);/,m){print "\""m[1]"\""}' "/etc/setup/setup.rc") )
      ;;
    --file|-f)
      COMPREPLY=( \$(compgen -f -- "\$cur") )
      ;;
    --proxy|-p)
      COMPREPLY=( auto inherit none http:// )
      ;;
    *)
      COMPREPLY+=( "${OPTIONS[*]}" )
      ;;
  esac
  if [ -n "\$DEBUG_COMPLETION" ]; then
    echo
    echo "COMP_WORDBREAKS: \$COMP_WORDBREAKS"
    echo "getsubcmd: '\${getsubcmd[@]}'"
    echo "subcmd: '\${subcmd[@]}'"
    echo "COMP_LINE: '\${COMP_LINE}'"
    echo "cur: \$cur"
    echo "prev: \$prev"
    echo "COMP_WORDS: \${COMP_WORDS[@]}"
    echo
    echo -n "\${COMP_LINE}"
  fi
  COMPREPLY=( \$(compgen -W "\${COMPREPLY[*]}" -- "\$cur") )
  __ltrim_colon_completions "\$cur"
}
complete -F __apt-cyg apt-cyg
EOD
  touch -r "$SCRIPTFILE" "/etc/bash_completion.d/apt-cyg"
  echo "A bash completion /etc/bash_completion.d/apt-cyg is installed"
}

function apt-cyg-completion-uninstall ()
{
  if [ ! -f /etc/bash_completion.d/apt-cyg ]; then
    echo -e "\e[31;1mError:\e[30;0m /etc/bash_completion.d/apt-cyg is not exist."
    exit 1
  fi
  rm /etc/bash_completion.d/apt-cyg
  echo "A bash completion /etc/bash_completion.d/apt-cyg is uninstalled"
}

function apt-cyg-mirrors-list ()
{
  awk '
    /^[^ \t]+/ {section = $1}
    section=="mirrors-lst" && match($0, /^[ \t]+([^;]+);/, m) {print m[1]}
  ' "/etc/setup/setup.rc"
}

function apt-cyg-benchmark-mirrors ()
{
  local mirror result exitcode
  for mirror; do
    result="$( { time wget -qO/dev/null -T3 -t 1 "${mirror%/}/$(current_cygarch)/setup.bz2"; } 2>&1 )"
    exitcode=$?
    if [ $exitcode -ne 0 ];then
      echo -e "\e[33;1mWarning:\e[30;0m benchmark failed with wget exitcode $exitcode: $(wget-exitstatus $exitcode): $1" >&2
      continue
    fi
    echo -e "$(echo "$result" | grep real | cut -f 2 | tr -d "\n")\t${mirror}"
  done
}

function apt-cyg-benchmark-parallel-mirrors ()
{
  local result="$(mktemp --tmpdir "${SCRIPTNAME}.$$.XXXXX")"
  local mirror
  for mirror; do echo $mirror; done | lesser-parallel apt-cyg-benchmark-mirrors {} | tee "$result"
  echo Finished benchmark.
  echo ========================================
  echo Sorted result.
  sort -rV "$result"
  rm "$result"

}

function apt-cyg-benchmark-parallel-mirrors-list ()
{
  local mirrors
  readarray -t mirrors < <(apt-cyg-mirrors-list)
  apt-cyg-benchmark-parallel-mirrors "${mirrors[@]}"
}

function apt-cyg-scriptinfo ()
{
cat<<EOD
SCRIPT_PATH     = "$SCRIPT_PATH"
SCRIPT_FILE     = "$SCRIPT_FILE"
SCRIPT_NAME     = "$SCRIPT_NAME"
SCRIPT_DIR      = "$SCRIPT_DIR"
SCRIPT_REALPATH = "$SCRIPT_REALPATH"
SCRIPT_REALFILE = "$SCRIPT_REALFILE"
SCRIPT_REALNAME = "$SCRIPT_REALNAME"
SCRIPT_REALDIR  = "$SCRIPT_REALDIR"
EOD
}

# Usage: isbusy [file ...]
function isbusy ()
{
  perl -e 'foreach $i(@ARGV){if(-f $i){open(DATAFILE,"+<",$i)||exit(0);close(DATAFILE);}}exit(1);' -- "$@"
}

function apt-cyg-show-packages-busyness ()
{
  local pkg lst files
  for pkg; do
    lst="/etc/setup/${pkg}.lst.gz"
    if [ -e "$lst" ]; then
      readarray -t files < <(gzip -dc "$lst"|sed 's:^:/:g')
      isbusy "${files[@]}" && echo -n "busy: " || echo -n "free: "
      echo "$pkg"
    fi
  done
}

function get_codepage ()
{
  cmd.exe /c chcp | awk '{printf $NF;}' | sed -re 's/^[^0-9]*([0-9]+).*$/CP\1/g'
}

function cp2utf8 ()
{
  iconv -f $(get_codepage) -t UTF-8
}

# dummy command for unknown sum.
# Usage: unknownsum
function unknownsum ()
{
  return 1
}

# Determine the hash method from a HASH.
# Usage: hash_method HASH
function hash_method ()
{
  case "${#1}" in
    32)  echo md5     ;;
    40)  echo sha1    ;;
    56)  echo sha224  ;;
    64)  echo sha256  ;;
    96)  echo sha384  ;;
    128) echo sha512  ;;
    *)   echo unknown ;;
  esac
}

# Read md5 and sha{1,224,256,384,512} sums from the FILEs and check them.
# Usage: hash_check [FILE ...]
function hash_check ()
{
  local f0 f1 f2 method count=0
  while true; do
    while read f0; do
      f1="${f0% *}"
      f2="${f0#*\*}"
      method="$(hash_method "$f1")sum"
      if echo "$f0" | "$method" -c --status; then
        verbose 0 "hash_check: $method: $f2: OK"
      else
        verbose 0 "hash_check: $method: $f2: FAILED"
        count=$(( count + 1 ))
      fi
    done 0<${1:-<(cat)}
    shift
    (( $# <= 0 )) && break
  done
  if (( 0 < count )); then
    verbose 0 "hash_check: WARNING: $count computed checksum did NOT match"
    return 1
  fi
  return 0
}

function kill_all_cygwin_process ()
{
  local family
  local pid=$BASHPID
  local pslog=$(ps -f | tail -n +2 | awk '{print $2, $3}')
  readarray -t family < <(echo "$pslog" | awk -v pid=$pid '
    {ppids[$1] = $2;}
    END {while (1 < pid) {print "-e\n"pid; pid = ppids[pid];}}
  ')
  kill -9 $(echo "$pslog" | grep -v "${family[@]}" | awk '{print $1}') ${family[$((${#family[@]} - 1))]}
}

function apt-cyg-update-setup ()
{
  [ -n "$OPT_NO_UPDATE_SETUP" ] && return
  
  pushd "$(apt-cyg-pathof cache)" > /dev/null
  
  if "${WGET[@]}" -N "https://cygwin.com/${SETUP_EXE}"; then
    chmod +x "${SETUP_EXE}"
    ls -l "${SETUP_EXE}" > $(verbosefor 2)
  else
    echo -e "\e[31;1mError:\e[30;0m ${SETUP_EXE} could not be downloaded."
    exit 1
  fi
  
  popd > /dev/null
}

function use_own_conf ()
{
  local opts=()
  if [ -n "$OPT_USE_OWN_CONF" ]; then
    local  cache="$(apt-cyg-pathof cache)"
    local mirror="$(apt-cyg-pathof mirror)"
    [ -n "$cache"  ] && opts+=( -l "$(cygpath -wa "$cache")" )
    [ -n "$mirror" ] && opts+=( -s "$mirror" )
  fi
  join $'\n' "${opts[@]}"
}

function apt-cyg-setup ()
{
  pushd "$(apt-cyg pathof cache)" > /dev/null
  
  local opts; readarray -t opts < <(use_own_conf)
  local setup=( "./${SETUP_EXE}" "${opts[@]}" "$@" )
  
  apt-cyg-update-setup
  "${setup[@]}"
  
  popd > /dev/null
}

function apt-cyg-dist-upgrade-no-ask ()
{
  local opts; readarray -t opts < <(use_own_conf)
  local setup=( ".\\${SETUP_EXE}" -B -q -n -g "${opts[@]}")
  
  pushd "$(apt-cyg-pathof cache)" > /dev/null
  
  apt-cyg-update-setup
  cygstart cmd /c 'ECHO Press any key to start dist-upgrade for cygwin '"$(current_cygarch)"' && PAUSE && START /WAIT '"${setup[@]}"' && ash -c "/bin/rebaseall -v" && ECHO dist-upgrade is finished && ECHO Press any key to exit && PAUSE' # '
  kill_all_cygwin_process
  
  popd > /dev/null
}

function apt-cyg-dist-upgrade ()
{
  echo "Kill all cygwin process and start dist-upgrade."
  ask_user "Are you sure ?" && {
    echo "Start dist-upgrade ..."
    sleep 1
    apt-cyg-dist-upgrade-no-ask
  } || {
    echo "Abort."
  }
}

function apt-cyg-packages-total-count ()
{
  grep ^@ <"$(apt-cyg pathof setup.ini)" | wc -l
}

# Usage: apt-cyg-packages-total-size [pattern_of_section]
function apt-cyg-packages-total-size ()
{
  local section="^$"
  (( 0 < $# )) && section="$1"
  
  awk -v SECTION="$section" '
    /^@ [ -~]+ *$/ {section = ""}
    match($0,/^\[([ -~]*)\] *$/,m) {section = m[1]}
    match(section, SECTION) && $1 == "install:" {sum += $3}
    END {print sum}
  ' "$(apt-cyg pathof setup.ini)"
}

function apt-cyg-packages-cached-count ()
{
  pushd "$(apt-cyg pathof cache/mirrordir)" > /dev/null
  find . -type f | grep tar | wc -l
  popd > /dev/null
}

function apt-cyg-packages-cached-size ()
{
  pushd "$(apt-cyg pathof cache/mirrordir)" > /dev/null
  find . -type f -iname '*tar*' -exec ls -l {} + \
  | awk '{sum+=$5}END{print sum}'
  popd > /dev/null
}

function apt-cyg-repair-acl ()
{
  local target="${1:-/}"
  local aclbackup="/tmp/$(date +%Y%m%d_%H%M%S)_acl"
  ask_user "$(cat <<-EOD
	This subcommand tries to repair the ACL for "${target}".
	Maybe it repairs a cygwin that was installed by setup.exe with -B and --no-admin options.
	But some package, that are failed to install by the ACL problem, need to be reinstalled.
	
	And unfortunately, perchance, this might cause some corruptions about the ACL.
	You can find a backup of the ACL before being rewritten by this subcommand at below:
	  "${aclbackup}.bin"
	  "${aclbackup}.txt"
	
	Are you sure ?
	EOD
  )" || exit 1
  echo
  
  cmd /c icacls "$(cygpath -w "${target}")" /save "$(cygpath -w "${aclbackup}.bin")" > /dev/null
  cmd /c icacls "$(cygpath -w "${target}")" | cp2utf8 > "$(cygpath -w "${aclbackup}.txt")"
  
  cmd /c icacls "$(cygpath -w "${target}")" \
    /grant \
      "%USERDOMAIN%\\%USERNAME%:F" \
      "*S-1-3-1:RX" \
      "Everyone:RX" \
      "CREATOR OWNER:(OI)(CI)(IO)F" \
      "CREATOR GROUP:(OI)(CI)(IO)RX" \
      "Everyone:(OI)(CI)(IO)RX" \
    /remove \
      "NT AUTHORITY\\Authenticated Users" \
      "NT AUTHORITY\\SYSTEM" \
      "BUILTIN\\Administrators" \
      "BUILTIN\\Users" \
      "NULL SID" \
    /inheritance:r \
  | cp2utf8
}

function get_archives_list () #= section type [package_names ...]
#? get archives list by format below:
#?    path size digest
#?    ...
#? @param section takes section name like curr, prev, test and etc,,,
#? @param type takes type name like install or source.
{
  local section="$1"
  local type="$2"
  shift 2
  awk -v RS="\n\n@ " -v FS="\n" -v PKGS="$(join $'\x1c' "$@")" -v MIRROR="${mirror%/}/" \
    -v SECTION="$section" -v TYPE="$type" '
    BEGIN {
      split(PKGS, tmp, "\x1c");
      for (k in tmp) pkgs[tmp[k]] = k; # swap key value
    }
    {
      if(pkgs[$1] == "") {
        delete pkgs[$1];
      } else {
      section = "curr";
      for (i = 2; i <= NF; i++) {
        if (match($i, /^\[.*\]$/, m)) {
          section = m[1];
        } else if (match($i, TYPE ": *(.*)", m) && section == SECTION) {
          result[0+n++]=m[1];
          delete pkgs[$1]
        }
      }
    }
    }
    END {
      for (i =0; i < n; i++) {
        print result[i];
      }
      if (0 < length(pkgs)) {
        printf("\x1b[33;1mWarning:\x1b[0m following packages are not found:")>"/dev/stderr";
        for (pkg in pkgs) printf(" %s", pkg)>"/dev/stderr";
        printf("\n")>"/dev/stderr";
      }
    }
  ' "$(apt-cyg-pathof "setup.ini")"
}

function download_packages () #= pos section type [package_names ...]
#? download packages
#? @param pos takes here or mirror.
#? @param section takes section name like curr, prev, test and etc,,,
#? @param type takes type name like install or source.
{
  local pos="$1"
  local section="$2"
  local type="$3"
  shift 3
  
  case "$pos" in
  here)
    ;;
  mirror)
    cd "$(apt-cyg pathof cache/mirrordir)"
    ;;
  *)
    echo -e "\e[31;1mError:\e[0m unknown param: $pos"
    exit 1
    ;;
  esac
  
  local mirror="$(apt-cyg pathof mirror)"
  local line
  local pkgs="$(get_archives_list "$section" "$type" "$@")"
  local total="$(echo "$pkgs" | awk '{sum+=$2}END{print sum;}')"
  local n="$(echo "$pkgs" | wc -l)"
  echo "$n packages, total $total bytes will be downloaded."
  echo "$pkgs" | while read line; do
    local tmp=( $line )
    local path="${tmp[0]%/*}/"
    local file="${tmp[0]##*/}"
    local url="${mirror%/}/${tmp[0]}"
    local size="${tmp[1]}"
    local digest="${tmp[2]}"
    if [ "$pos" = "mirror" ]; then  
      mkdir -vp "$path"
      pushd "$path"
    fi
    "${WGET[@]}" -N "$url"
    if ! hash_check <<<"${digest} *${file}" ; then
      verbose 1 -e "\e[31;1mError:\e[0m ${BASH_SOURCE[0]}: ${FUNCNAME[0]}: ${BASH_LINENO[0]}: hash did not match: $file"
    fi
    [ "$pos" = "mirror" ] && popd
  done
}

function apt-cyg-source ()
{
  download_packages here curr source "$@"
}

function apt-cyg-download ()
{
  download_packages here curr install "$@"
}

function apt-cyg-mirror ()
{
  download_packages mirror curr install "$@"
}

PACKAGEOF_CACHE="/tmp/.apt-cyg-packageof.cache.gz"
function update_packageof_cache ()
{
  local i=0 p q path fn
  local chr=( "=" "-" "/" "|" "\\" )
  local lstgz_stamp="$(find /etc/setup/ -maxdepth 1 -type f -name '*.lst.gz' -exec stat -c %Y {} + | sort | tail -n1)"
  local cache_stamp="$(stat "$PACKAGEOF_CACHE" -c %Y 2>/dev/null || echo 0)"
  local n="$(ls -1 /etc/setup/*.lst.gz|wc -l)"
  
  if (( cache_stamp < lstgz_stamp )) || [ -n "$OPT_FORCE_UPDATE_PACKAGEOF_CACHE" ]; then
    verbose 1 "Updating packageof cache:" >&2
    progress_init
    for path in /etc/setup/*.lst.gz; do
      progress_update $(( i++ )) $n
      local fn="${path##*/}"
      zcat "$path" | awk -v PKGNAME="${fn%.lst.gz}" '{print PKGNAME ": " $0;}'
#      printf "p=%d q=%d i=%d n=%d path=[%s]\n" $p $q $i $n "$path"
    done | gzip >"$PACKAGEOF_CACHE"
    progress_finish
  fi
}

PROGRESS_CHAR=( "=" "-" "/" "|" "\\" )
function progress_init ()
{
  [ -n "$OPT_NO_PROGRESS" ] && return
  #          0        1         2         3         4         5
  #          12345678901234567890123456789012345678901234567890
  echo -ne "|..................................................|\r" >"$verbosefor0"
}

function progress_update () #= current total=100
{
  [ -n "$OPT_NO_PROGRESS" ] && return
  local n=${2:-100}
  local p=$((2 + 50 * ($1    ) / $n))
  local q=$((2 + 50 * ($1 + 1) / $n))
  if (( q - p <= 1 )); then
    printf "\e[%dG%s" $p "${PROGRESS_CHAR[($1 % 4 + 1) * (1 + $p - $q)]}" >"$verbosefor0"
  else
    printf "\e[%dG%s" $p "$(seq $((q - p))|awk '{printf "="}')" >"$verbosefor0"
  fi
}

function progress_finish ()
{
  [ -n "$OPT_NO_PROGRESS" ] && return
  echo >"$verbosefor0"
}

# Lesser Parallel for Embedding
# Copyright (c) 2014 Koichi OKADA. All rights reserved.
# The official repository is:
# https://github.com/kou1okada/lesser-parallel
# This script is distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

LESSER_PARALLEL_MAX_JOBS=${LESSER_PARALLEL_MAX_JOBS:-8}

function lesser-parallel-get-jobs-count ()
{
  jobs -l >/dev/null
  jobs -l | wc -l
}

# Usage: lesser-parallel-restrict-jobs-count MAXJOBS
function lesser-parallel-restrict-jobs-count ()
{
  while [ $(lesser-parallel-get-jobs-count) -ge $1 ]; do
    sleep 0.2
  done
}

# Usage: lesser-parallel [command [arguments]] < list_ot_arguments
function lesser-parallel ()
{
  local cmd arg lines line basename ext PARALLEL_SEQ=1
  readarray -t lines
  for line in "${lines[@]}"; do
    basename="$(basename "$line")"
    ext="${basename##*.}"
    [ "$ext" = "$basename" ] && ext=""
    [ "$ext" != "" ] && ext=".$ext"
    cmd=( )
    for arg; do
      case "$arg" in
      "{}")
        cmd+=( "$line" )
        ;;
      "{.}")
        cmd+=( "$(basename "$line" "$ext")" )
        ;;
      "{/}")
        cmd+=( "$basename" )
        ;;
      "{//}")
        cmd+=( "$(dirname "$line")" )
        ;;
      "{/.}")
        cmd+=( "$(basename "$basename" "$ext")" )
        ;;
      "{#}")
        cmd+=( "$PARALLEL_SEQ" )
        ;;
      *)
        cmd+=( "$arg" )
        ;;
      esac
    done
    
    lesser-parallel-restrict-jobs-count $LESSER_PARALLEL_MAX_JOBS
    
    "${cmd[@]}" &
    PARALLEL_SEQ=$[$PARALLEL_SEQ + 1]
  done
  
  lesser-parallel-restrict-jobs-count 1
}

#/Lesser Parallel for Embedding

function apt-cyg-help ()
{
  usage
}

# process options

noscripts=0
OPT_USER_PICKED=1
noupdate=0
OPT_FILES=()
SUBCOMMAND=""
ignore_case=""
force_remove=""
force_fetch_trustedkeys=""
no_verify=""
OPT_PROXY=${APT_CYG_PROXY:-auto}
OPT_PROXY_REFRESH_INTERVAL=${APT_CYG_PROXY_REFRESH_INTERVAL:-86400} # 86400s = 1day
OPTS4INHERIT=()
SETUP_EXE="setup-$(current_cygarch).exe"
YES_TO_ALL=false
INITIAL_ARGS=( "$@" )
ARGS=()

function parse_args ()
{
  local unknown_option END_OPTS
  
  while [ $# -gt 0 ]; do
    case "$1" in
      
      --ag)
        OPT_AG="$1"
        shift
        ;;
      
      --charch)
        OPT_CHARCH="$2"
        shift 2 || break
        ;;
      
      --use-setuprc)
        "$0" -c "$(grep -aA1 '^last-cache$'  /etc/setup/setup.rc | tail -n1 | cp2utf8 | sed -r 's/^\s*|\s*$//g')" > /dev/null
        "$0" -m "$(grep -aA1 '^last-mirror$' /etc/setup/setup.rc | tail -n1           | sed -r 's/^\s*|\s*$//g')" > /dev/null
        shift
        ;;
      
      --use-own-conf)
        OPT_USE_OWN_CONF="$1"
        shift
        ;;
      
      --ignore-case|-i)
        ignore_case="$1"
        shift
        ;;
      
      --force-remove)
        force_remove=1
        shift
        ;;
      
      --force-fetch-trustedkeys)
        force_fetch_trustedkeys=1
        shift
        ;;
      
      --force-update-packageof-cache)
        OPT_FORCE_UPDATE_PACKAGEOF_CACHE="$1"
        shift
        ;;
      
      --no-verify|-X)
        OPTS4INHERIT+=( "$1" )
        no_verify=1
        shift
        ;;
      
      --no-check-certificate)
        OPTS4INHERIT+=( "$1" )
        WGET+=( "--no-check-certificate" )
        shift
        ;;
      
      --no-update-setup)
        OPT_NO_UPDATE_SETUP="$1"
        shift
        ;;
      
      --no-header)
        OPT_NO_HEADER="$1"
        shift
        ;;
      
      --proxy|-p)
        OPT_PROXY="$2"
        shift 2 || break
        ;;
      
      --proxy-force-refresh)
        OPT_PROXY_FORCE_REFRESH="$1"
        shift
        ;;
      
      --proxy-refresh-interval)
        OPT_PROXY_REFRESH_INTERVAL="$2"
        shift 2 || break
        ;;
      
      --completion-get-subcommand)
        OPT_COMPLETION_GET_SUBCOMMAND="$1"
        shift
        ;;
      
      --completion-disable-autoupdate)
        OPT_COMPLETION_DISABLE_AUTOUPDATE="$1"
        shift
        ;;
      
      --max-jobs|-j)
        LESSER_PARALLEL_MAX_JOBS="$2"
        shift 2 || break
        ;;
      
      --mirror|-m)
        OPT_MIRROR="$2"
        shift 2 || break
        ;;
      
      --cache|-c)
        OPT_CACHE="$2"
        shift 2 || break
        ;;
      
      --noscripts)
        noscripts=1
        shift
        ;;
      
      # It will not register the user_picked flag in PACKAGE_DB.
      # This option is for internal use only.
      --no-user-picked)
        OPT_USER_PICKED=0
        shift
        ;;
      
      --noupdate|-u)
        noupdate=1
        shift
        ;;
      
      --ipv4|-4)
        WGET=( "${WGET[@]}" "--prefer-family=IPv4" )
        shift
        ;;
      
      --no-progress)
        OPT_NO_PROGRESS="$1"
        shift
        ;;
      
      --quiet|-q)
        OPT_VERBOSE_LEVEL=-1
        shift
        ;;
      
      --verbose|-v)
        OPT_VERBOSE_LEVEL=2
        shift
        ;;
      
      --help)
        usage
        exit 0
        ;;
      
      --version)
        version
        exit 0
        ;;
      
      --file|-f)
        [ -n "$2" ] && OPT_FILES+=( "$2" )
        shift 2 || break
        ;;
      
      --)
        END_OPTS="$1"
        shift
        break
        ;;
      
      -*)
        unknown_option="$1"
        break
        ;;
      
      *)
        if [ -z "$SUBCOMMAND" ]; then
          SUBCOMMAND="$1"
        else
          ARGS+=( "$1" )
        fi
        shift
        
        ;;
      
    esac
  done
  [ -n "$END_OPTS" ] && while (( 0 < "$#" )); do ARGS+=( "$1" ); shift; done
  
  if [ -n "$OPT_COMPLETION_GET_SUBCOMMAND" ]; then
    echo "$SUBCOMMAND"
    exit
  fi
  
  if [ -n "$unknown_option" ]; then
    echo -e "\e[31;1mError:\e[30;0m Unknown option: $unknown_option"
    exit 1
  fi
  
  if [ $# -gt 0 ]; then
    echo -e "\e[31;1mError:\e[30;0m Number of parameters is not enough: $@"
    exit 1
  fi
  
} #/parse_args

parse_args "$@"

: ${OPT_VERBOSE_LEVEL:=1}

[ -n "$OPT_CHARCH" ] && charch "$OPT_CHARCH" "${INITIAL_ARGS[@]}"

[ "${#OPT_MIRROR[@]}" -gt 0 ] && echo "${OPT_MIRROR%/}/"             > /etc/setup/last-mirror
[ "${#OPT_CACHE[@]}"  -gt 0 ] && echo "$(cygpath -aw "$OPT_CACHE")"  > /etc/setup/last-cache

if [ -z "$GPGV" -a -z "$no_verify" ]; then
  echo -e "\e[31;1mError:\e[30;0m GnuPG is not installed. Prease install gnupg package or use -X option."
  exit 1
fi

for file in "${OPT_FILES[@]}"; do
  if [ -f "$file" ]; then
    readarray -t -O ${#ARGS[@]} ARGS < "$file"
  else
    echo File $file not found, skipping
  fi
done

wget --help | grep -- --show-progress &>/dev/null && HAVE_SHOW_PROGRESS="--show-progress"
wget --help | grep -- --no-verbose    &>/dev/null && HAVE_NO_VERBOSE="--no-verbose"
(( "${OPT_VERBOSE_LEVEL}" < 0 )) && WGET+=( --quiet ) || \
(( "${OPT_VERBOSE_LEVEL}" < 1 )) && WGET+=( --quiet $HAVE_SHOW_PROGRESS ) || \
(( "${OPT_VERBOSE_LEVEL}" < 2 )) && WGET+=( $HAVE_NO_VERBOSE $HAVE_SHOW_PROGRESS )
verbosefor0=$(verbosefor 0)
verbosefor1=$(verbosefor 1)
verbosefor2=$(verbosefor 2)
verbosefor3=$(verbosefor 3)
verbosefor4=$(verbosefor 4)
verbosefor5=$(verbosefor 5)

if [ -n "$OPT_AG" ]; then
  AG="$( which ag 2>/dev/null )"
  if [ -z "$AG" ]; then
    echo -e "\e[33;1mWarning:\e[0m ag is not found."
    unset OPT_AG
  fi
fi



function apt-cyg-update ()
{
  findworkspace
  getsetup
}


function apt-cyg-show ()
{
  package_db-version_check
  [ -z "$OPT_NO_HEADER" ] && echo "The following packages are installed:"
  package_db-list
}


function apt-cyg-find ()
{
  local pkg
  
  checkpackages "$@"
  findworkspace
  getsetup
  
  for pkg do
    echo ""
    echo "Searching for installed packages matching $pkg:"
    package_db-list | awk '$1~query{print $1}' query="$pkg" IGNORECASE="$ignore_case"
    echo ""
    echo "Searching for installable packages matching $pkg:"
    awk -v query="$pkg" -v IGNORECASE="$ignore_case" \
      'BEGIN{RS="\n\n@ "; FS="\n"; ORS="\n"} {if ($1 ~ query) {print $1}}' \
      setup.ini
  done
}


function apt-cyg-describe ()
{
  local pkg
  
  checkpackages "$@"
  findworkspace
  getsetup
  for pkg do
    echo ""
    awk -v query="$pkg" -v IGNORECASE="$ignore_case" \
      'BEGIN{RS="\n\n@ "; FS="\n"; ORS="\n"} {if ($1 ~ query) {print $0 "\n"}}' \
      setup.ini
  done
}

function apt-cyg-packageof ()
{
  if [ -z "$OPT_AG" ]; then
    update_packageof_cache
    zcat "$PACKAGEOF_CACHE" | grep "$@"
  else
    "$AG" -z "$@" /etc/setup/*.lst.gz
  fi
}

function apt-cyg-install ()
{
  local pkg
  local script
  
  package_db-version_check
  checkpackages "$@"
  findworkspace
  getsetup
  
  for pkg do
    if package_db-is_registered "$pkg"; then
      echo Package $pkg is already installed, skipping
      continue
    fi
    verbose 0 ""
    verbose 0 "Installing $pkg"
    
    # look for package and save desc file
    
    mkdir -p "release/$pkg"
    awk > "release/$pkg/desc" -v package="$pkg" \
      'BEGIN{RS="\n\n@ "; FS="\n"} {if ($1 == package) {desc = $0; px++}} \
       END {if (px == 1 && desc != "") print desc; else print "Package not found"}' \
       setup.ini
    local desc="$(< "release/$pkg/desc")"
    if [ "$desc" = "Package not found" ]; then
      verbose 0 "Package $pkg not found or ambiguous name, exiting"
      rm -r "release/$pkg"
      exit 1
    fi
    verbose 0 "Found package $pkg"
    
    # download and unpack the bz2 file
    
    # pick the latest version, which comes first
    local install="$(awk '/^install: / { print $2; exit }' "release/$pkg/desc")"
    
    if [ -z "$install" ]; then
      verbose 0 "Could not find \"install\" in package description: obsolete package?"
      exit 1
    fi
    
    local file="$(basename "$install")"
    cd "release/$pkg"
    "${WGET[@]}" -Nc $mirror/$install
    
    # check the SHA512 hash
    local digest="$(awk '/^install: / { print $4; exit }' "desc")"
    if ! hash_check <<<"${digest} *${file}" ; then
      verbose 0 "error: hash did not match: $file"
      exit 1
    fi
    
    verbose 0 "Unpacking..."
    tar > "/etc/setup/$pkg.lst" xvf "$file" -C /
    gzip -f "/etc/setup/$pkg.lst"
    cd ../..
    
    
    # update the package database
    
    package_db-register "$file" "$OPT_USER_PICKED"
    
    
    # recursively install required packages
    
    local requires="$(grep "^requires: " "release/$pkg/desc" | sed -re 's/^requires: *(.*[^ ]) */\1/g' -e 's/ +/ /g')"
    
    local warn=0
    if [ -n "$requires" ]; then
      verbose 0 "Package $pkg requires the following packages, installing:"
      verbose 0 "$requires"
      for package in $requires; do
        if package_db-is_registered "$package"; then
          verbose 0 "Package $package is already installed, skipping"
          continue
        fi
        apt-cyg "${OPTS4INHERIT[@]}" --proxy inherit --noscripts --no-user-picked install $package
        if [ $? -ne 0 ]; then warn=1; fi
      done
    fi
    if [ $warn -ne 0 ]; then
      echo "Warning: some required packages did not install, continuing"
    fi
    
    # run all postinstall scripts
    
    local pis="$(ls /etc/postinstall/*.sh 2>/dev/null | wc -l)"
    if [ $pis -gt 0 -a $noscripts -ne 1 ]; then
      verbose 0 "Running postinstall scripts"
      for script in /etc/postinstall/*.sh; do
        $script
        mv $script $script.done
      done
    fi
    
    verbose 0 "Package $pkg installed"
    
  done
}


function apt-cyg-remove()
{
  local pkg
  local req
  
  package_db-version_check
  checkpackages "$@"
  for pkg do
    if ! package_db-is_registered "$pkg"; then
      verbose 0 "Package $pkg is not installed, skipping"
      continue
    fi
    
    local dontremove="cygwin coreutils gawk bzip2 tar xz wget bash"
    for req in $dontremove; do
      if [ "$pkg" = "$req" ]; then
        verbose 0 "apt-cyg cannot remove package $pkg, exiting"
        exit 1
      fi
    done
    
    if [ ! -e "/etc/setup/$pkg.lst.gz" -a -z "$force_remove" ]; then
      verbose 0 "Package manifest missing, cannot remove $pkg.  Exiting"
      exit 1
    fi
    verbose 0 "Removing $pkg"
    
    # run preremove scripts
    
    local i postinstalls preremoves
    readarray -t postinstalls < <(zgrep -E "^etc/postinstall/.*[.]sh$"    "/etc/setup/${pkg}.lst.gz" | awk '{print "/"$0}')
    readarray -t preremoves   < <(zgrep -E "^etc/preremove/.*[.](da)?sh$" "/etc/setup/${pkg}.lst.gz" | awk '{print "/"$0}')
    for i in "${preremoves[@]}"; do
      verbose 0 "Running: ${i}"
      "${i}"
    done
    
    gzip -cd "/etc/setup/$pkg.lst.gz" | awk '/[^\/]$/{printf("/%s\0", $0)}' | xargs -0 rm -f
    gzip -cd "/etc/setup/$pkg.lst.gz" | awk '/[^./].*[/]$/{printf("/%s\0", $0)}' | sort -zr | xargs -0 rmdir --ignore-fail-on-non-empty
    rm -f "${postinstalls[@]/%/.done}" "/etc/setup/$pkg.lst.gz"
    package_db-unregister "$pkg"
    verbose 0 "Package $pkg removed"
    
  done
}

function invoke_subcommand ()
{
  local SUBCOMMAND="${@:1:1}"
  local ARGS=( "${@:2}" )
  local ACTION="apt-cyg-${SUBCOMMAND:-help}"
  if type "$ACTION" >& /dev/null; then
    "$ACTION" "${ARGS[@]}"
  else
    echo -e "\e[31;1mError:\e[30;0m unknown subcommand: $SUBCOMMAND"
    exit 1
  fi
}

SCRIPT_PATH="$(which "$0")"
SCRIPT_FILE="${SCRIPT_PATH##*/}"
SCRIPT_NAME="${SCRIPT_FILE%.*}"
SCRIPT_DIR="${SCRIPT_PATH%/*}"
SCRIPT_REALPATH="$(realpath "$(which "$0")")"
SCRIPT_REALFILE="${SCRIPT_REALPATH##*/}"
SCRIPT_REALNAME="${SCRIPT_REALFILE%.*}"
SCRIPT_REALDIR="${SCRIPT_REALPATH%/*}"

proxy_setup
invoke_subcommand "$SUBCOMMAND" "${ARGS[@]}"
